ROSE (A Real Time Java Based Operating System Emulator)
=======================================================
Dr. Mantis H.M. Cheng 
Dept. of Computer Science
University of Victoria
Date: 23 August 2002


Section 1) Introduction
=======================

ROSE was designed as a pedagogical tool to teach operating system and
concurrency concepts in C and Java. ROSE is not intended to be
compatible with the standard Java's concurrency model. Instead, it replaces
Java with a totally different model of concurrency. Its aim is to 
show how "new" concurrency support could be added in a language runtime 
system such as Java. We simplify the basic model of Java thread, i.e.,
we only include what is necessary to create, start and stop threads. We
add a scheduler and a set of concurrent primitives implemented by native 
methods. The basic Java VM remains mostly unchanged. In order to support
pre-emptive scheduling, we add a processor dependent timing facility to
provide a millisecond accurate software interrupt. That is, the Java VM is
"interrupted" every millisecond and passes its control to the scheduler.
The scheduler then decides which runnable thread is eligible to execute
next. Since the JVM is a simple stack-based virtual machine, context
switching is drastically simplified; we only need to save and restore
the current VM's program counter and stack pointer.

The concepts and implementation of a concurrent runtime system are quite
similar to those supported by an OS or by a "thread" package. An application
in ROSE will be written in standard Java. We use a standard SUN JDK to
develop and compile our application code. To keep the JVM size small, we
have choosen the SimpleRTJ JVM because it uses a "statically-linked" 
architecture to execute Java byte code. As such, ROSE doesn't support 
dynamic loading of class files. All Java application code 
(i.e., all class files) must be linked into a single binary image. 
This image will be loaded into memory in its entirety for execution.

ROSE doesn't provide any windowing libraries. But, a few basic Java i/o
operations are supported. ROSE is a pedagogical tool, not a production
development platform. At this moment, ROSE does not provide AWT,
networking, remote method invocation, etc. Just the basic Java language
with a new concurrency library is supported.


Section 2) Using ROSE
=====================
ROSE does not use any standard thread support in Java. Instead, it defines
its own thread model and concurrency primitives. Furthermore, ROSE uses
a totally different scheduling policy.

We define a collection of "uvic" ROSE specific packages. At this moment,
under the "./lib-source" directory, you'll find our Java library code
under "uvic/posix" for the package "uvic.posix". The uvic.posix package
defines 4 classes: Thread, Mutex, Semaphore and Condition.  These classes 
are all implemented in C inside the ROSE JVM [in the "./rose" directory]. 
(See below about how to change/add primitives in ROSE.)

ROSE currently supports 4 scheduling levels: SYSTEM (0), REAL_TIME (1), 
USER (2) and DAEMON(3). SYSTEM is the highest level. When "main()" is
started, it runs as a SYSTEM level thread.

SYSTEM and DAEMON level threads are FCFS. REAL_TIME and USER level threads
are time-sliced, with 1 and 2 ticks respectively. A tick is given at the
command line of ROSE. The command

	rose 10 <appl>.bin

starts ROSE with a quantum of 10 milliseconds.

To use threads, you must import the "uvic.posix" package. Since the standard
Java also defines a Thread class, you need to specify "uvic.posix.Thread" to
use ROSE's threads.

To use the JDK javac compiler, please specify the following CLASSPATH:

.:../lib/ClassLinker.jar;../lib/uvic.jar;../lib/java.jar;../lib

We'll use the Simple RTJ ClassLinker to link all compiled class files into
a single binary image. The ClassLinker requires a per-application control
file. If your application is called "test.java", which defines the main()
method, then you need a "test.control" file. There are many options in
the control file. The most important one is the "LinkClassPath", which
should include

.;../lib/java.jar;../lib/uvic.jar

Currently, ROSE was developed using GCC and Cygwin under Windows (NT/2000/XP).
The executable "rose.exe" generated by GCC/Cygwin MUST be run under Cygwin
shell window, not inside a DOS command window. All makefiles, GCC compiler,
and JDK javac compiler have been tested using Cygwin. You should not need
any additional tools.

ROSE uses the following directory structure:

./rose        -- the source code and binary executable of "rose"
./lib         -- precompiled and archived Java class libraries
./lib-source  -- the Java libary source files, including uvic.posix
./test1       -- a simple Java program for testing "rose"

Each directory has its own "makefile". Please consult for details.

(Note: 
If you receive a copy of ROSE in a tar-zipped file, e.g., "rose.tgz",
you can install ROSE by entering the following inside a Cygwin shell window:

	tar xzvf rose.tgz

This will create the above directories under the current directory. Also,
if you want to submit your solutions to the marker. You can tar-zip your
directories as follows.

	tar czvf project1.tgz ./rose ./project1

This will create a "project1.tgz" which contains both "./rose" and 
"./project1" directories. In most cases, you won't need to make any changes
in the "./lib" and "./lib-source" directories. So, you don't need to include
them in your solutions.

End Note.)


Section 3) Changes made to Simple RTJ JVM
=========================================

In the following, we summarize the changes made to SimpleRTJ JVM to build
ROSE. There are basically three areas of modification:
a) timing (not the interval asynchronous event timer);
b) native methods for concurrency support; and
c) thread scheduling and concurrency primitives.

No changes were made to byte code interpreter (j_bcode.c), garbage collection
(j_gc.c), floating point support (j_float.c), and heap memory management 
(j_mem.c).


a) Timing Facility

To support millisecond accurate software timer interrupt, we chose to use
the Pentium processor's profiling clock. Reading the processor's profiling
clock requires little overhead. Internally, we maintain a 64-bit global

	long long vm_time_ms;  [in j_vars.c, jcommon.h]

as our ROSE VM clock. This clock is updated whenever the function

	UpdateVMTimer();   [in timer.c]

is called. The function InitVMTimer() [in timer.c] checks whether the host
processor supports the high resolution profiling timer. StartVMTimer() will
initialize vm_time_ms and set up a base start time.

The JVM's vmStart() function [in j_vm.c] will initialize this timing 
facility. Inside the byte code interpreting loop (the run() function),
the timer is checked after every instruction and VMTick() (see below) is
called when a tick has expired.


b) Native Methods for Concurrency Support

We added a "uvic.posix" package under "../lib-source" directory. For example,
in our "uvic.posix" package, we provide a "Mutex" class defined as follows.

	public class Mutex {
	   public Mutex { ... }
	   public Lock() { ... }
	   public UnLock() { ... }
	}

These are then supported by the following native methods:

	int init_mutex();
	void lock_mutex( int m );
	void unlock_mutex( int m );

These native methods are unknown to the standard Java compiler. We must
inform our static linker (ClassLinker.jar [in ../lib]) about these
native methods. We add the following entries

	uvic/posix/Mutex.init_mutex
	uvic/posix/Mutex.lock_mutex
	uvic/posix/Mutex.unlock_mutex

in the ClassLinker.control file. A corresponding table for native methods
is initialized in the "native_func_ptr" [at the end of j_lang.c]. Note the
order of the entries in ClassLinker.control and "native_func_ptr" MUST be
matched. This is how this JVM invokes the right native method by indexing
into the corresponding entry. (N.B. Each time we modify the 
ClassLinker.control file, we need to update the ClassLinker.jar file by
running "make" under "../lib" directory.)

From the "native_func_ptr" table [in j_lang.c], we establish the following 
function pointers:

	uvic_posix_Mutex_init_mutex
	uvic_posix_Mutex_lock_mutex
	uvic_posix_Mutex_unlock_mutex

which then call the appropriate "real" native methods. For example, we
have in "j_thread.c" the functions:

	int MutexInit();
	void MutexLock( int m );
	void MutexUnLock( int m );

As a result, the method call m.Lock() where m is of type Mutex will bind to
our native C method "MutexLock(m)".


c) Scheduling and Concurrency Primitives

We have completely abandoned the original thread support in SimpleRTJ JVM. 
We modify "struct thread_T" [in jvm.h] to reflect what we need. We add
the following scheduling primitives [in j_thread.c, jcommon.h]:

	typedef struct thread_T thread_t;

	InitROSE();
	AddReady( thread_t *p, bool front );
	Dispatch();
	PreemptIfNecessary()
	Reschedule();     /* same as yield() */
	AssignQuantum( thread_t *p );
	VMTick();

Our "new" concurrent primitives will use these scheduling primitives to
interact with the JVM. Our scheduler maintains a global variable:

	thread_t  *thr_active;   

which refers to the currently running thread, and a few internal critical
variables:

	thread_t  *ready_q;      /* the queue of READY threads */
	thread_t  *dead_pool;    /* a set of DEAD threads */
	thread_t  threads[];     /* the thread descriptor table */

Similarly, we also maintain a few tables for Mutexes, Conditions and Semaphores.
They'll be initialized when InitROSE() is called. The memory storage for these
tables will be allocated inside the VM's heap. The allocation is done inside
vmStart() [in j_vm.c].


Section 3.1 Configurating ROSE
==============================

The file "jvm_cfg.h" contains the following limits.

  /* standard JVM limits */
#define MAX_REFERENCES	1024
#define MAX_STRINGS	1024
#define MAX_HEAPSIZE	128000
#define MAX_TIMERS	0     /* not used */
#define MAX_EVENTS	0     /* not used */

The important ones are:

#define MAX_THREADS	64    /* including the main() thread */
#define MAX_MUTEXES	32    /* max. no. of Mutexes supported */
#define MAX_CONDITIONS	32    /* max. no. of Conditions supported */
#define MAX_PRI_LEVELS	4     /* 0 is the highest */

Currently, we support four priority levels. The Java main() thread is 
created as a SYSTEM level thread by default. SYSTEM and DAEMON level threads
are FCFS, REAL_TIME and USER level threads are time-sliced.

  /* priority levels */
#define SYSTEM_LEVEL      0
#define REAL_TIME_LEVEL   1
#define USER_LEVEL        2
#define DAEMON_LEVEL      3
